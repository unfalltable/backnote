---
title: JavaSe面试题
toc: content
keywords: [interview]
---

## 集合

### 概念

#### 简单介绍JDK中的集合

- 首先他们都是基础Collection类

- 集合主要分为单值存储和键值存储的

- 主要分为list、set、map

  |          | list | set  | map  |
  | -------- | ---- | ---- | ---- |
  | 元素重复 | √    | ×    | ×    |
  | null值   |      |      |      |
  | 速度     |      |      |      |

### HashMap

#### HashMap用红黑树？为什么不用AVL树 

- 用树结构主要是用来避免DoS攻击，防止链表超长时性能下降

- 红黑树插入删除快，AVL慢，因为AVL旋转次数更多，平衡和调试更难，但AVL读取快，适合读取密集型任务

#### HashMap红黑树何时会退化？

- 当因为扩容时导致树的节点少于6时会退化为链表

- 当删除树的节点时，主要看root，root.left，root.right，root.left.left
  - 如果删除前以上节点还存在则不会退化为链表，反之退化

#### HashMap树化阈值为什么为8？

- hash值如果足够随机，则在hash表内按泊松分布，在负载因子为0.75的情况下，链表长度超过8的概率为 6*10^-7^ 

#### 索引如何计算？

- 计算对象的hashCode()，再调用HashMap的hash()方法进行第二次哈希运算，最后 & (容量 - 1) 得到索引
  - 二次哈希值 = 原始哈希code ^ 原始哈希code>>>16
  - 注意这里的容量必须是2的n次幂

#### 已经有hashCode方法为什么还要提供hash方法？

- 为了使哈希分布更加均匀，减少哈希碰撞

#### 容量为何是2的n次幂？

- 在HashMap中进行二次hash时可以用按位与运算代替掉取模运算，从而提升一定的计算性能

#### 扩容时如何确定新位置？

- 1.8才有的优化
  - 在扩容时会将元素的二次hash值 和 未扩容前的原始容量 进行按位与（**&**）运算
    - 如果结果为0，表示这些元素扩容后位置不会发生改变
    - 如果结果不为0，则表示这些元素将移动到新的位置

    - 新的位置 = 原始位置 + 原始容量

  - 会把结果为0的和结果不为0的串成两条链表，批量操作

#### 如果容量不是2的n次幂呢？

- 容量是2的n次幂存在一个问题，当要存储的元素奇偶分布不均时，哈希分布就不那么均匀了

- 把容量设置为一个质数可以解决这个问题

- 设置为质数可以在第一次hash时就能有不错的散列分布

- 如果想要好的性能则选2的n次幂，想要更好的散列分布则选质数

#### 扩容因子为什么默认是0.75？ 

- 在空间占用和查询时间之间取得较好的平衡

- 大于这个值，空间节省了，但是链表较长影响性能

- 小于这个值，冲突减少了，但链表扩容频繁，空间占用多

#### 多线程下hashMap存在什么问题？

- jdk7有扩容死链问题
  - 是因为1.7扩容后的链表会以头插法插入
  - 当多个线程同时进行扩容时，一个线程扩容后次序改变了，另一个线程再扩容导致死链

 - jdk8有数据丢失问题
   - 当多个线程同时往map的同一个位置存放数据时，容易出现覆盖丢失数据

