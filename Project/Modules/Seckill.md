

## 总体思路

- 秒杀最主要的是查看商品详情页和下单两个模块
- 查看商品详情页
  - 前端从CDN上取得页面数据，后端将页面静态化后存到cdn上
  - 添加nginx做负载均衡，然后用redis缓存，nginx访问redis
    - redis中没有数据再去查JVM缓存
    - JVM缓存中没有再去查数据库
- 下单
  - 

## 全局唯一ID

- 需要满足唯一性，安全性，高可用，高性能
- 使用Redis中的incrby实现
  - 符号位（1）+ 时间戳（31）+ 序列号（32）
    - 时间戳 = 当前时间 - 自定义的一个过去的时间常量
    - 序列号 = “一些前缀” + 当前时间 + 1
    - 返回     时间戳 << 32 | 序列号
- 使用雪花算法
  - 1bit + 时间戳（41）+ 机器id（10）+ 序列号（12）
  - 同一毫秒生成的id不超过4095，超过4095则到下一毫秒生成
  - 由于每一台机器的工作机器id不同，所以分布式环境下也不会冲突

## 防止库存超卖

- CAS

- Synchronize

- 分布式锁

## 一人一单

- 需要在扣减库存前进行判断，并且把判断过程和扣减库存用synchronize锁住
- 以userId作为锁
- 在分布式系统下无法保证，需要使用分布式锁

## 异步秒杀

- 由于当前大多数业务都是在tomcat中串行执行的，效率低
- 把秒杀券信息也保存到redis中
- 所以我们可以把判断库存、扣减库存和一人一单校验放在redis中进行
  - 使用lua脚本确保原子性
- 用户秒杀成功后将优惠券id和用户id存入**阻塞队列**中，将订单id返回给用户
- 开启线程任务不断读取**阻塞队列**中的订单异步下单

## 消息队列

- 使用Stream的Group（消费组）实现消息队列

  - 消息分流
    - 队列中的消息会分流给组内不同的消费者，从而加快消息处理速度
  - 消息标示
    - 会维护一个标识记录最后一个被处理的消息，即使宕机重启，还会从标识之后读取消息，确保每一个消息都被消费
  - 消息确认
    - 消费者获得消息后，消息会处于pending状态，并存入一个pending-list，当处理完消息后需要通过XACK来确认消息，标记消息已处理，才会从pending-list移除
  - 可以阻塞读取
  - 消息可回溯，即持久化存储

  #### 步骤

  - 创建一个StreamGroup类型的消息队列，名为stream.orders
    - `XGROUP CREATE stream.orders g1 0 MKSTREAM`
  - 使用lua脚本向消息队列中添加消息
  - 开启一个线程从消息队列中取出消息
    - 判断信息是否为空
      - 空继续下一轮循环
      - 非空解析信息然后创建订单
  - 确认消息队列中的消息
  - 如果这个过程出现异常需要处理pending-list