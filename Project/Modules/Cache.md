# 用户缓存

- 查询数据时先去Redis缓存中找，有就返回，没有再到数据库找，减少数据库压力
- 查询数据库后将结果写入缓存，然后返回给客户端
- 主动更新策略
  - 选择删除缓存，等待有查询时在更新缓存，延迟加载
    - 如果每次更新数据库都更新缓存，无效的写操作太多
  - 选择先更新数据库再更新缓存
    - 如果先删除缓存再更新数据库，当线程1删除缓存后正在更新数据库时，线程2去查询缓存未命中，然后线程2去查数据库，会将数据库旧数据写入缓存中

## 缓存预热

- 主从之间数据吞吐量较大、数据同步操作频度高、请求数量较高，而且redis中没有数据，导致redis启动时快速宕机，所以需要进行预热
- 日常需要对数据的访问进行记录，统计热点数据
- 利用LRU（）数据删除策略，构建数据留存队列
- redis启动时加载热点数据
  - 使用脚本固定触发数据预热

## 缓存雪崩

- 在较短时段内大量的缓存失效或者redis宕机，导致大量的请求打到数据库
- 给不同的缓存key的有效期加上随机的时间
  - 不同业务过期时间不同
  - 对超级热点数据使用永久key
- 利用redis集群
- 给缓存业务添加降级限流策略
- 给业务添加**多级缓存** 
- 优化数据库中严重耗时的业务
- redis监控服务器性能指标
- 把缓存key到期删除策略改成按命中次数删除策略

## 缓存击穿

- 一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求会打到数据库
- 使用互斥锁进行缓存重建
  - 没有额外内存消耗，保证一致性，实现简单，但是性能受影响，可能出现死锁
  - 利用Redis的 SETNX 实现，只有第一个执行SETNX的成功
  - 或者使用Redisson的分布式锁
- 逻辑过期
  - 即热点数据缓存不设置过期时间，而是在其对象中设置一个时间属性，在这上面设置过期时间
  - 查询缓存中这条数据时判断是否过期即可
  - 过期则加锁开启一个线程进行缓存重建
  - 性能较好，但不保证一致性，有额外内存消耗，实现复杂

## 缓存穿透

- 缓存穿透是指客户端请求的数据在缓存和数据库中的不存在，这些请求都会打到数据库
- 使用缓存空对象解决
  - 实现简单，维护方便，但会带来额外的内存消耗，可能造成短期的不一致
- 使用布隆过滤器解决，在客户和缓存之间添加
  - 内存占用少，实现复杂，存在误判
- 增强id的复杂度
- 加强用户权限校验
- 做好热点参数的限流